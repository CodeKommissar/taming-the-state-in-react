# Introduction

State management in applications got a popular topic in the recent years. Single page applications (SPAs) - that are only delivered once from a web server yet stay interactive - have to establish state management in the frontend. They have to keep the state consistent without making any more requests to the backend. They have to give the user an effortless and pleasant experience when using the application. It already starts when you want to open a popup in your application. Someone has to be aware of this state. But who manages the state?

jQuery was a popluar library before the first SPA solutions like Angular, Ember and Backbone appeared. State management itself wasn't a huge problem in jQuery in the beginning, because the library was most often only used for selective DOM manipulations. You could add animations to your HTML, add or remove DOM nodes or change the style of your HTML dynamically.

Eventually the jQuery code, and in general the portion of JavaScript code compared to HTML and CSS grew, and people wrote more sophisticated frontend applications. Most of the time, it ended up in a mess of jQuery code where not only state management was a problem, but also general best practices like clean code were missing. There was no solution for the general architecture of these kind of frontend applications and people stuggled to keep it maintainable in larger applications.

After a while, single page application (SPA) solutions like Angular, Ember and Backbone emerged to give these unstructured frontend applications a proper framework around them. The greater part of the SPAs build up on the model-view-controller (MVC) pattern to architect the application. These frameworks contain everything you would need, from a view layer for displaying HTML in the browser to a model layer for interacting with your backend, to build your sophisticated application. The term SPA was coined, because these applications were only served once from the backend, as a single page, but then operated only in the frontend. They are big blobs of JavaScript which contain everything the applications needs to work on the client-side. When navigating to a different page under a different URL, there is no reloading required. They only interacted with the backend to pull or push new data from or to it. Thus, the only thing that changes is the data inside the application. But who manages this data?

Even though these solutions established best practices, patterns and architectures for the first generation of SPAs, state management was still a reoccuring issue. When interacting with the backend to retrieve new data, it was unclear how to manage the data in a predictable way. When triggering view related elements, such as modals or popups, in the frontend, there was often no established best practice to manage these states. Every framework tried to apply their own solution for it. Eventually people came up with there own best practices and libraries, but it became never a predictable and consistent experience to manage state with clear constraints.

There was one major flaw with these SPA solutions that led to this problem in the first place: As frameworks they tried to solve too many issues at once. They wouldn't have the chance to solve all issues in the first generation of their existence in the world of SPAs. Eventually they solved these issues in the future when other SPA solutions appeared on the scene.

The second generation of SPA solutions, among them libraries like React and Vue, focused only on smaller parts of the application. They focused on the view layer. It was up to the engineer to decide on further libraries as solutions for specific problems. [That's what made React such a powerful library in the first place](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/), because everyone could decide to extend the application with libraries that solve specific yet small problems.

Nowadays, a ton of articles and libraries try to solve the issue of state management. It is difficult to find a consistent source of truth to learn state management in modern applications. Even though, solutions like React have their own state management implementation for local state in components, there are more external solutions coming as libraries to establish sophisitcated state management.

Still, it lacks one guide to navigate through all these different solutions to make the differences and benefits clear. Often the guides miss the point of teaching the problem first. In addition, instead of showing the minimal approach, they try to fix the problem of state management by using overengineered approaches. But it can be so much simpler. It only needs one resource to guide through state management in modern applications in a consistent and constructive way.

If you want to learn something, you have to do it step by step. Trying to solve each atomic problem after the next one. Don't apply everything at once. Understand the problem and solve it. That's my attempt with the *Taming the State*: It doesn't teach only Redux in React, but modern state managament in modern applications. It goes beyond the documentation of state management libraries, but applies the learnings in real world applications end-to-end in the book.

These are the heroes of the book: Local State (in React), Redux and MobX. It wouldn't have been possible to write the book without the great innovators behind the technologies: [Dan Abramov](https://twitter.com/dan_abramov), [Andrew Clark](https://twitter.com/acdlite) and [Michel Weststrate](https://twitter.com/mweststrate). I guess, I can thank them in the name of the community for their efforts to make state management in modern applications a consistent experience.